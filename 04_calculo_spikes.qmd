# Cálculo de *spikes*  

## Lectura de los datos

### Descripción 
Para gestión de la información se utilizará la biblioteca de pandas, no es necesario gestionar la memoria porque las arquitecturas de nuestros ordenadores la manejan sin problemas. 

La estructura de los ficheros viene dada en la información de los datos, en el fichero 
`InformacionFicheros.txt` y en las tres primeras líneas de los mismos (las cuales deberán de ser obviadas para la lectura del fichero). 

### Requisitos 
- Tener las respectivas biblioteca instaladas (pandas, matplotlib y numpy). 
- Los datos deben encontrarse en el path indicado en la variable `data_path`. 

En el siguiente fragmento de código puede observar la cabecera de los datos: 

- El intervalo de muestreo es de $0.1 ms$.
- Hay dos canales, una por cada neurona.
- Y en total se han tomado $19847700$ muestreos. 


```{python}
print('Datos fichero trozo C')
print(23*'-')
!head -n 14 ./DatosSinapsisArtificial/InformacionFicheros.txt
```

```{python}
## Data information 
sample_interval = 0.1
samples_per_channel_trozoC = 19847700
```
## Lectura de los datos  

Para la lectura de los datos se va a utilizar la biblioteca *Pandas* y la función `read_csv` puede encontrar la implementación de la misma en el directorio `src/read_data.py`. 

```{python}
from src.read_data import read_data

data_path = './DatosSinapsisArtificial/'
fileTrozoC , fileTrozoG, fileTrozoR = map( 
    lambda letra: data_path+'Trozo'+ letra + '.zip',
    "C G R".split()
    )
columns_names = ["LP", "VD"]
#["LP", "VD", "GABAInjection"]
trozoC = read_data(fileTrozoC, columns_names)
trozoC.head(4)
```
Figura 1: Primeras 4 filas de la señal leída.   

## Diseño del algoritmo de cálculo de *spikes*  

Para calcular los *spikes* se ha optado por utilizar un doble umbral 
la descripción del algoritmo es la siguiente y la puede encontrar en el fichero `src/signal_to_binary.py`: 

Dada una señal `signal` que es una lista unidimensional de la señal. 
Para que cuento como señal debe de superar el umbral superior `upper_threshold` y ser la primera 
vez o que ya se haya alcanzado un valor inferior a `lower_threshold`.

Además una vez que se supera el umbral se colocará cuando la tendencia vaya a bajar.
Esto queda reflejado con los siguientes estados: 

- **Estado 1**: 
Si `s > upper_threshold` entonces :
i) `last = s`
ii) pasar a estado 2.

- **Estado 2**: 
Si `s` < `last` entonces:
i) poner un spike en señal anterior
ii) `last = -inf`
iii) pasar a estado 3
Si no entonces: 
i) last = s 

- **Estado 3**: 
Si `s < lower_threshold` entonces:
i) Cambiar a estado 1
 
___

### Motivación del algoritmo 

Notemos que este algoritmo detecta el *spike* como el primer instante antes de que la señal empiece a decaer (punto azul) y en situaciones donde tras una caída no lo suficientemente baja y una subida aunque sea superior (punto amarillo) se tomaría al primero como punto de *spike*.

![Dualidad spikes](img/04_calculo_spikes/dualidad_spikes.png)  

Esta decisión se ha tomado ya que filosóficamente se podría entender *spike* como el instante en el que toma un *valor grande* y que el resto son obscilaciones del pico. En caso de que se desee tener el valor amarillo bastaría con subir el umbral superior. 


## Determinación de los umbrales  

Para determinar los umbral 
vamos a suponer que la señal sigue una distribución normal, 
ya que este tipo de distribución modela fenómenos con mecanismos complejos y desconocidos.

La distribución normal posee la propiedad de que 

Porcentaje de la población dentro de la normal | Distancia a la media   
:-: | :-: 
$80\%$ | $1.281 \sigma$  
$90\%$ | $1.645 \sigma$  
$95\%$ | $1.956 \sigma$  
$99\%$ | $2.576 \sigma$  
$99.9\%$ | $3.291 \sigma$   
$99.99\%$ | $3.891 \sigma$  
$99.999\%$ | $4.892 \sigma$  


Los *impulsos* son eventos *raros* y por tanto serán aquellos que se encuentren más alejados de la media más

Hemos realizado por tanto un experimento para ver la dependencia entre el umbral seleccionado y el número de *spikes* detectados. 

Éste consiste en variar los umbrales conforme a la distancia a media y ver el número el número de spikes detectados (puede consultar la implementación en `src/get_thresholds.py`) 

El experimento puede ser ejecutado con `make experimento_umbrales` y se encuentra implementado en  el fichero `src/experiment_gets_threshold.py`. 

Los resultados han sido los siguientes: 

       
 Distancia del umbral bajo | Distancia alta | Umbral bajo| Umbral alto| Número de *spikes*
:-: |:-: |:-: |:-: |:-:   
1.956 | 1.956| -0.161 | 0.161 | 54464  
1.956 | 2.57| -0.161 | 0.211 | 41905  
1.956 | 4.892| -0.161 | 0.402 | 31065  
2.57 | 1.956| -0.211 | 0.161 | 45446  
2.57 | 2.57| -0.211 | 0.211 | 38986  
2.57 | 4.892| -0.211 | 0.402 | 31064  
4.892 | 1.956| -0.402 | 0.161 | 10408  
4.892 | 2.57| -0.402 | 0.211 | 10343  
4.892 | 4.892| -0.402 | 0.402 | 10241  


Vemos que el umbral bajo determina crucialmente el número de *spikes* realizaremos una inspencción viual para ver qué está acontenciendo en varias secciones aleatorias de la muestra (si se encuentra en un entorno de ejecución podría modificar los valores de `higher_thresholds` y de `lower_threshold`).  


```{python}
from src.get_thresholds import plotThreshold
import numpy as np

higher_threshold =  0.402 
lower_threshold  = -0.402

LP = "LP"
img_path = "img/04_calculo_spikes/"
sample_interval = 0.1
x_trozoC = sample_interval * np.arange(start=0, stop=samples_per_channel_trozoC)
slice = 8200#10000

for init in [1000, 5000, 10000]:
    plotThreshold(
        x_trozoC[init:slice+init],
        (trozoC[LP].to_list())[init:slice+init], 
            img_path+f'init{init}.png',
            lower_threshold,
            higher_threshold,
            show_graph = True)

```


A la vista de las imágenes está fijaremos 

```{python}
upper_threshold =  0.402 
lower_threshold  = -0.320

LP = "LP"
img_path = "img/04_calculo_spikes/"
sample_interval = 0.1
x_trozoC = sample_interval * np.arange(start=0, stop=samples_per_channel_trozoC)
slice = 8200#10000

for init in [1000, 5000, 10000]:
    plotThreshold(
        x_trozoC[init:slice+init],
        (trozoC[LP].to_list())[init:slice+init], 
            img_path+f'init{init}_lower{lower_threshold}_upper{upper_threshold}.png',
            lower_threshold,
            higher_threshold,
            show_graph = True)

```

Hemos repetido el experimento para cada uno de los trozos y cada neurona. Puede consultar los resultados en el apéndice \ref{appendix:experiment_gets_threshold} o bien ejecutarlos por si mismo `make experimento_umbrales`; ese comando mostrará los resultados en la terminal y además los almacenará en el directorio `experiment_results/get_threshold.txt`.  

